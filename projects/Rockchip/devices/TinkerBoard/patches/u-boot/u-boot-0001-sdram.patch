From 41e4fb6ef19af931b25f5111ffd4be88e5f6fca2 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 18 Jun 2017 00:10:47 +0200
Subject: [PATCH 1/2] Revert "rockchip: use common sdram function"

This reverts commit cc763d4f6f468ef6daacb0077faa1da2c887c719.
---
 arch/arm/include/asm/arch-rockchip/ddr_rk3288.h   |  48 +++++++++
 arch/arm/mach-rockchip/rk3188-board.c             |  22 +++++
 arch/arm/mach-rockchip/rk3188/sdram_rk3188.c      |  61 ++++++++++--
 arch/arm/mach-rockchip/rk3288-board.c             |  22 +++++
 arch/arm/mach-rockchip/rk3288/sdram_rk3288.c      |  74 ++++++++++----
 arch/arm/mach-rockchip/rk3399/sdram_rk3399.c      |  91 ++++++++++++++++-
 board/rockchip/evb_rk3328/evb-rk3328.c            |   6 ++
 board/rockchip/evb_rk3399/evb-rk3399.c            |  22 +++++
 board/theobroma-systems/puma_rk3399/puma-rk3399.c | 113 +++-------------------
 9 files changed, 326 insertions(+), 133 deletions(-)

diff --git a/arch/arm/include/asm/arch-rockchip/ddr_rk3288.h b/arch/arm/include/asm/arch-rockchip/ddr_rk3288.h
index 35696c741f..9a59075afc 100644
--- a/arch/arm/include/asm/arch-rockchip/ddr_rk3288.h
+++ b/arch/arm/include/asm/arch-rockchip/ddr_rk3288.h
@@ -441,4 +441,52 @@ enum {
 /* mr1 for ddr3 */
 #define DDR3_DLL_DISABLE		1
 
+/*
+ *TODO(sjg@chromium.org): We use a PMU register to store SDRAM information for
+ * passing from SPL to U-Boot. It would probably be better to use a normal C
+ * structure in SRAM.
+ *
+ * sys_reg bitfield struct
+ * [31] row_3_4_ch1
+ * [30] row_3_4_ch0
+ * [29:28] chinfo
+ * [27] rank_ch1
+ * [26:25] col_ch1
+ * [24] bk_ch1
+ * [23:22] cs0_row_ch1
+ * [21:20] cs1_row_ch1
+ * [19:18] bw_ch1
+ * [17:16] dbw_ch1;
+ * [15:13] ddrtype
+ * [12] channelnum
+ * [11] rank_ch0
+ * [10:9] col_ch0
+ * [8] bk_ch0
+ * [7:6] cs0_row_ch0
+ * [5:4] cs1_row_ch0
+ * [3:2] bw_ch0
+ * [1:0] dbw_ch0
+*/
+#define SYS_REG_DDRTYPE_SHIFT		13
+#define SYS_REG_DDRTYPE_MASK		7
+#define SYS_REG_NUM_CH_SHIFT		12
+#define SYS_REG_NUM_CH_MASK		1
+#define SYS_REG_ROW_3_4_SHIFT(ch)	(30 + (ch))
+#define SYS_REG_ROW_3_4_MASK		1
+#define SYS_REG_CHINFO_SHIFT(ch)	(28 + (ch))
+#define SYS_REG_RANK_SHIFT(ch)		(11 + (ch) * 16)
+#define SYS_REG_RANK_MASK		1
+#define SYS_REG_COL_SHIFT(ch)		(9 + (ch) * 16)
+#define SYS_REG_COL_MASK		3
+#define SYS_REG_BK_SHIFT(ch)		(8 + (ch) * 16)
+#define SYS_REG_BK_MASK			1
+#define SYS_REG_CS0_ROW_SHIFT(ch)	(6 + (ch) * 16)
+#define SYS_REG_CS0_ROW_MASK		3
+#define SYS_REG_CS1_ROW_SHIFT(ch)	(4 + (ch) * 16)
+#define SYS_REG_CS1_ROW_MASK		3
+#define SYS_REG_BW_SHIFT(ch)		(2 + (ch) * 16)
+#define SYS_REG_BW_MASK			3
+#define SYS_REG_DBW_SHIFT(ch)		((ch) * 16)
+#define SYS_REG_DBW_MASK		3
+
 #endif
diff --git a/arch/arm/mach-rockchip/rk3188-board.c b/arch/arm/mach-rockchip/rk3188-board.c
index 3e76100ad1..4be711e441 100644
--- a/arch/arm/mach-rockchip/rk3188-board.c
+++ b/arch/arm/mach-rockchip/rk3188-board.c
@@ -72,6 +72,28 @@ err:
 #endif
 }
 
+int dram_init(void)
+{
+	struct ram_info ram;
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
+	if (ret) {
+		debug("DRAM init failed: %d\n", ret);
+		return ret;
+	}
+	ret = ram_get_info(dev, &ram);
+	if (ret) {
+		debug("Cannot get DRAM size: %d\n", ret);
+		return ret;
+	}
+	debug("SDRAM base=%lx, size=%x\n", ram.base, ram.size);
+	gd->ram_size = ram.size;
+
+	return 0;
+}
+
 #ifndef CONFIG_SYS_DCACHE_OFF
 void enable_caches(void)
 {
diff --git a/arch/arm/mach-rockchip/rk3188/sdram_rk3188.c b/arch/arm/mach-rockchip/rk3188/sdram_rk3188.c
index 9e058a55f6..fea8007265 100644
--- a/arch/arm/mach-rockchip/rk3188/sdram_rk3188.c
+++ b/arch/arm/mach-rockchip/rk3188/sdram_rk3188.c
@@ -22,7 +22,6 @@
 #include <asm/arch/grf_rk3188.h>
 #include <asm/arch/pmu_rk3188.h>
 #include <asm/arch/sdram.h>
-#include <asm/arch/sdram_common.h>
 #include <linux/err.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -797,7 +796,49 @@ error:
 	printf("DRAM init failed!\n");
 	hang();
 }
+#endif /* CONFIG_SPL_BUILD */
+
+size_t sdram_size_mb(struct rk3188_pmu *pmu)
+{
+	u32 rank, col, bk, cs0_row, cs1_row, bw, row_3_4;
+	size_t chipsize_mb = 0;
+	size_t size_mb = 0;
+	u32 ch;
+	u32 sys_reg = readl(&pmu->sys_reg[2]);
+	u32 chans;
+
+	chans = 1 + ((sys_reg >> SYS_REG_NUM_CH_SHIFT) & SYS_REG_NUM_CH_MASK);
+
+	for (ch = 0; ch < chans; ch++) {
+		rank = 1 + (sys_reg >> SYS_REG_RANK_SHIFT(ch) &
+			SYS_REG_RANK_MASK);
+		col = 9 + (sys_reg >> SYS_REG_COL_SHIFT(ch) & SYS_REG_COL_MASK);
+		bk = 3 - ((sys_reg >> SYS_REG_BK_SHIFT(ch)) & SYS_REG_BK_MASK);
+		cs0_row = 13 + (sys_reg >> SYS_REG_CS0_ROW_SHIFT(ch) &
+				SYS_REG_CS0_ROW_MASK);
+		cs1_row = 13 + (sys_reg >> SYS_REG_CS1_ROW_SHIFT(ch) &
+				SYS_REG_CS1_ROW_MASK);
+		bw = (2 >> ((sys_reg >> SYS_REG_BW_SHIFT(ch)) &
+			SYS_REG_BW_MASK));
+		row_3_4 = sys_reg >> SYS_REG_ROW_3_4_SHIFT(ch) &
+			SYS_REG_ROW_3_4_MASK;
+		chipsize_mb = (1 << (cs0_row + col + bk + bw - 20));
+
+		if (rank > 1)
+			chipsize_mb += chipsize_mb >>
+				(cs0_row - cs1_row);
+		if (row_3_4)
+			chipsize_mb = chipsize_mb * 3 / 4;
+		size_mb += chipsize_mb;
+	}
+
+	/* there can be no more than 2gb of memory */
+	size_mb = min(size_mb, 0x80000000 >> 20);
+
+	return size_mb;
+}
 
+#ifdef CONFIG_SPL_BUILD
 static int setup_sdram(struct udevice *dev)
 {
 	struct dram_info *priv = dev_get_priv(dev);
@@ -874,15 +915,12 @@ static int rk3188_dmc_probe(struct udevice *dev)
 {
 #ifdef CONFIG_SPL_BUILD
 	struct rk3188_sdram_params *plat = dev_get_platdata(dev);
-	struct regmap *map;
-	struct udevice *dev_clk;
-	int ret;
 #endif
 	struct dram_info *priv = dev_get_priv(dev);
+	struct regmap *map;
+	int ret;
+	struct udevice *dev_clk;
 
-	priv->pmu = syscon_get_first_range(ROCKCHIP_SYSCON_PMU);
-
-#ifdef CONFIG_SPL_BUILD
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	ret = conv_of_platdata(dev);
 	if (ret)
@@ -894,9 +932,12 @@ static int rk3188_dmc_probe(struct udevice *dev)
 	priv->chan[0].msch = regmap_get_range(map, 0);
 
 	priv->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	priv->pmu = syscon_get_first_range(ROCKCHIP_SYSCON_PMU);
 
+#ifdef CONFIG_SPL_BUILD
 	priv->chan[0].pctl = regmap_get_range(plat->map, 0);
 	priv->chan[0].publ = regmap_get_range(plat->map, 1);
+#endif
 
 	ret = rockchip_get_clk(&dev_clk);
 	if (ret)
@@ -909,13 +950,13 @@ static int rk3188_dmc_probe(struct udevice *dev)
 	priv->cru = rockchip_get_cru();
 	if (IS_ERR(priv->cru))
 		return PTR_ERR(priv->cru);
+#ifdef CONFIG_SPL_BUILD
 	ret = setup_sdram(dev);
 	if (ret)
 		return ret;
-#else
-	priv->info.base = CONFIG_SYS_SDRAM_BASE;
-	priv->info.size = rockchip_sdram_size(&priv->pmu->sys_reg[2]);
 #endif
+	priv->info.base = CONFIG_SYS_SDRAM_BASE;
+	priv->info.size = sdram_size_mb(priv->pmu) << 20;
 
 	return 0;
 }
diff --git a/arch/arm/mach-rockchip/rk3288-board.c b/arch/arm/mach-rockchip/rk3288-board.c
index 5d72102856..6129a52475 100644
--- a/arch/arm/mach-rockchip/rk3288-board.c
+++ b/arch/arm/mach-rockchip/rk3288-board.c
@@ -158,6 +158,28 @@ err:
 #endif
 }
 
+int dram_init(void)
+{
+	struct ram_info ram;
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
+	if (ret) {
+		debug("DRAM init failed: %d\n", ret);
+		return ret;
+	}
+	ret = ram_get_info(dev, &ram);
+	if (ret) {
+		debug("Cannot get DRAM size: %d\n", ret);
+		return ret;
+	}
+	debug("SDRAM base=%lx, size=%x\n", ram.base, ram.size);
+	gd->ram_size = ram.size;
+
+	return 0;
+}
+
 #ifndef CONFIG_SYS_DCACHE_OFF
 void enable_caches(void)
 {
diff --git a/arch/arm/mach-rockchip/rk3288/sdram_rk3288.c b/arch/arm/mach-rockchip/rk3288/sdram_rk3288.c
index 4a9b5c9480..2feda61205 100644
--- a/arch/arm/mach-rockchip/rk3288/sdram_rk3288.c
+++ b/arch/arm/mach-rockchip/rk3288/sdram_rk3288.c
@@ -22,7 +22,6 @@
 #include <asm/arch/grf_rk3288.h>
 #include <asm/arch/pmu_rk3288.h>
 #include <asm/arch/sdram.h>
-#include <asm/arch/sdram_common.h>
 #include <linux/err.h>
 #include <power/regulator.h>
 #include <power/rk8xx_pmic.h>
@@ -924,7 +923,53 @@ error:
 	printf("DRAM init failed!\n");
 	hang();
 }
+#endif /* CONFIG_SPL_BUILD */
+
+size_t sdram_size_mb(struct rk3288_pmu *pmu)
+{
+	u32 rank, col, bk, cs0_row, cs1_row, bw, row_3_4;
+	size_t chipsize_mb = 0;
+	size_t size_mb = 0;
+	u32 ch;
+	u32 sys_reg = readl(&pmu->sys_reg[2]);
+	u32 chans;
+
+	chans = 1 + ((sys_reg >> SYS_REG_NUM_CH_SHIFT) & SYS_REG_NUM_CH_MASK);
+
+	for (ch = 0; ch < chans; ch++) {
+		rank = 1 + (sys_reg >> SYS_REG_RANK_SHIFT(ch) &
+			SYS_REG_RANK_MASK);
+		col = 9 + (sys_reg >> SYS_REG_COL_SHIFT(ch) & SYS_REG_COL_MASK);
+		bk = 3 - ((sys_reg >> SYS_REG_BK_SHIFT(ch)) & SYS_REG_BK_MASK);
+		cs0_row = 13 + (sys_reg >> SYS_REG_CS0_ROW_SHIFT(ch) &
+				SYS_REG_CS0_ROW_MASK);
+		cs1_row = 13 + (sys_reg >> SYS_REG_CS1_ROW_SHIFT(ch) &
+				SYS_REG_CS1_ROW_MASK);
+		bw = (2 >> ((sys_reg >> SYS_REG_BW_SHIFT(ch)) &
+			SYS_REG_BW_MASK));
+		row_3_4 = sys_reg >> SYS_REG_ROW_3_4_SHIFT(ch) &
+			SYS_REG_ROW_3_4_MASK;
+		chipsize_mb = (1 << (cs0_row + col + bk + bw - 20));
+
+		if (rank > 1)
+			chipsize_mb += chipsize_mb >>
+				(cs0_row - cs1_row);
+		if (row_3_4)
+			chipsize_mb = chipsize_mb * 3 / 4;
+		size_mb += chipsize_mb;
+	}
 
+	/*
+	* we use the 0x00000000~0xfdffffff space since 0xff000000~0xffffffff
+	* is SoC register space (i.e. reserved), and 0xfe000000~0xfeffffff is 
+	* inaccessible for some IP controller.
+	*/
+	size_mb = min(size_mb, 0xfe000000 >> 20);
+
+	return size_mb;
+}
+
+#ifdef CONFIG_SPL_BUILD
 # ifdef CONFIG_ROCKCHIP_FAST_SPL
 static int veyron_init(struct dram_info *priv)
 {
@@ -1042,16 +1087,12 @@ static int rk3288_dmc_probe(struct udevice *dev)
 {
 #ifdef CONFIG_SPL_BUILD
 	struct rk3288_sdram_params *plat = dev_get_platdata(dev);
-	struct udevice *dev_clk;
-	struct regmap *map;
-	int ret;
-#else
-	size_t size;
 #endif
 	struct dram_info *priv = dev_get_priv(dev);
+	struct regmap *map;
+	int ret;
+	struct udevice *dev_clk;
 
-	priv->pmu = syscon_get_first_range(ROCKCHIP_SYSCON_PMU);
-#ifdef CONFIG_SPL_BUILD
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	ret = conv_of_platdata(dev);
 	if (ret)
@@ -1066,12 +1107,14 @@ static int rk3288_dmc_probe(struct udevice *dev)
 
 	priv->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
 	priv->sgrf = syscon_get_first_range(ROCKCHIP_SYSCON_SGRF);
+	priv->pmu = syscon_get_first_range(ROCKCHIP_SYSCON_PMU);
 
+#ifdef CONFIG_SPL_BUILD
 	priv->chan[0].pctl = regmap_get_range(plat->map, 0);
 	priv->chan[0].publ = regmap_get_range(plat->map, 1);
 	priv->chan[1].pctl = regmap_get_range(plat->map, 2);
 	priv->chan[1].publ = regmap_get_range(plat->map, 3);
-
+#endif
 	ret = rockchip_get_clk(&dev_clk);
 	if (ret)
 		return ret;
@@ -1083,20 +1126,13 @@ static int rk3288_dmc_probe(struct udevice *dev)
 	priv->cru = rockchip_get_cru();
 	if (IS_ERR(priv->cru))
 		return PTR_ERR(priv->cru);
+#ifdef CONFIG_SPL_BUILD
 	ret = setup_sdram(dev);
 	if (ret)
 		return ret;
-#else
-	priv->info.base = CONFIG_SYS_SDRAM_BASE;
-	size = rockchip_sdram_size(priv->pmu->sys_reg[2]);
-
-	/*
-	* we use the 0x00000000~0xfdffffff space since 0xff000000~0xffffffff
-	* is SoC register space (i.e. reserved), and 0xfe000000~0xfeffffff is
-	* inaccessible for some IP controller.
-	*/
-	priv->info.size = min(size, 0xfe000000);
 #endif
+	priv->info.base = 0;
+	priv->info.size = sdram_size_mb(priv->pmu) << 20;
 
 	return 0;
 }
diff --git a/arch/arm/mach-rockchip/rk3399/sdram_rk3399.c b/arch/arm/mach-rockchip/rk3399/sdram_rk3399.c
index fd45d75330..536879d65b 100644
--- a/arch/arm/mach-rockchip/rk3399/sdram_rk3399.c
+++ b/arch/arm/mach-rockchip/rk3399/sdram_rk3399.c
@@ -14,7 +14,6 @@
 #include <syscon.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
-#include <asm/arch/sdram_common.h>
 #include <asm/arch/sdram_rk3399.h>
 #include <asm/arch/cru_rk3399.h>
 #include <asm/arch/grf_rk3399.h>
@@ -42,6 +41,50 @@ struct dram_info {
 	struct rk3399_pmugrf_regs *pmugrf;
 };
 
+/*
+ * sys_reg bitfield struct
+ * [31]		row_3_4_ch1
+ * [30]		row_3_4_ch0
+ * [29:28]	chinfo
+ * [27]		rank_ch1
+ * [26:25]	col_ch1
+ * [24]		bk_ch1
+ * [23:22]	cs0_row_ch1
+ * [21:20]	cs1_row_ch1
+ * [19:18]	bw_ch1
+ * [17:16]	dbw_ch1;
+ * [15:13]	ddrtype
+ * [12]		channelnum
+ * [11]		rank_ch0
+ * [10:9]	col_ch0
+ * [8]		bk_ch0
+ * [7:6]	cs0_row_ch0
+ * [5:4]	cs1_row_ch0
+ * [3:2]	bw_ch0
+ * [1:0]	dbw_ch0
+*/
+#define SYS_REG_DDRTYPE_SHIFT		13
+#define SYS_REG_DDRTYPE_MASK		7
+#define SYS_REG_NUM_CH_SHIFT		12
+#define SYS_REG_NUM_CH_MASK		1
+#define SYS_REG_ROW_3_4_SHIFT(ch)	(30 + (ch))
+#define SYS_REG_ROW_3_4_MASK		1
+#define SYS_REG_CHINFO_SHIFT(ch)	(28 + (ch))
+#define SYS_REG_RANK_SHIFT(ch)		(11 + (ch) * 16)
+#define SYS_REG_RANK_MASK		1
+#define SYS_REG_COL_SHIFT(ch)		(9 + (ch) * 16)
+#define SYS_REG_COL_MASK		3
+#define SYS_REG_BK_SHIFT(ch)		(8 + (ch) * 16)
+#define SYS_REG_BK_MASK			1
+#define SYS_REG_CS0_ROW_SHIFT(ch)	(6 + (ch) * 16)
+#define SYS_REG_CS0_ROW_MASK		3
+#define SYS_REG_CS1_ROW_SHIFT(ch)	(4 + (ch) * 16)
+#define SYS_REG_CS1_ROW_MASK		3
+#define SYS_REG_BW_SHIFT(ch)		(2 + (ch) * 16)
+#define SYS_REG_BW_MASK			3
+#define SYS_REG_DBW_SHIFT(ch)		((ch) * 16)
+#define SYS_REG_DBW_MASK		3
+
 #define PRESET_SGRF_HOLD(n)	((0x1 << (6 + 16)) | ((n) << 6))
 #define PRESET_GPIO0_HOLD(n)	((0x1 << (7 + 16)) | ((n) << 7))
 #define PRESET_GPIO1_HOLD(n)	((0x1 << (8 + 16)) | ((n) << 8))
@@ -1183,6 +1226,50 @@ static int rk3399_dmc_init(struct udevice *dev)
 }
 #endif
 
+size_t sdram_size_mb(struct dram_info *dram)
+{
+	u32 rank, col, bk, cs0_row, cs1_row, bw, row_3_4;
+	size_t chipsize_mb = 0;
+	size_t size_mb = 0;
+	u32 ch;
+
+	u32 sys_reg = readl(&dram->pmugrf->os_reg2);
+	u32 ch_num = 1 + ((sys_reg >> SYS_REG_NUM_CH_SHIFT)
+		       & SYS_REG_NUM_CH_MASK);
+
+	for (ch = 0; ch < ch_num; ch++) {
+		rank = 1 + (sys_reg >> SYS_REG_RANK_SHIFT(ch) &
+			SYS_REG_RANK_MASK);
+		col = 9 + (sys_reg >> SYS_REG_COL_SHIFT(ch) & SYS_REG_COL_MASK);
+		bk = 3 - ((sys_reg >> SYS_REG_BK_SHIFT(ch)) & SYS_REG_BK_MASK);
+		cs0_row = 13 + (sys_reg >> SYS_REG_CS0_ROW_SHIFT(ch) &
+				SYS_REG_CS0_ROW_MASK);
+		cs1_row = 13 + (sys_reg >> SYS_REG_CS1_ROW_SHIFT(ch) &
+				SYS_REG_CS1_ROW_MASK);
+		bw = (2 >> ((sys_reg >> SYS_REG_BW_SHIFT(ch)) &
+			SYS_REG_BW_MASK));
+		row_3_4 = sys_reg >> SYS_REG_ROW_3_4_SHIFT(ch) &
+			SYS_REG_ROW_3_4_MASK;
+
+		chipsize_mb = (1 << (cs0_row + col + bk + bw - 20));
+
+		if (rank > 1)
+			chipsize_mb += chipsize_mb >> (cs0_row - cs1_row);
+		if (row_3_4)
+			chipsize_mb = chipsize_mb * 3 / 4;
+		size_mb += chipsize_mb;
+	}
+
+	/*
+	 * we use the 0x00000000~0xf7ffffff space
+	 * since 0xf8000000~0xffffffff is soc register space
+	 * so we reserve it
+	 */
+	size_mb = min_t(size_t, size_mb, 0xf8000000/(1<<20));
+
+	return size_mb;
+}
+
 static int rk3399_dmc_probe(struct udevice *dev)
 {
 #ifdef CONFIG_SPL_BUILD
@@ -1194,7 +1281,7 @@ static int rk3399_dmc_probe(struct udevice *dev)
 	priv->pmugrf = syscon_get_first_range(ROCKCHIP_SYSCON_PMUGRF);
 	debug("%s: pmugrf=%p\n", __func__, priv->pmugrf);
 	priv->info.base = 0;
-	priv->info.size = rockchip_sdram_size((phys_addr_t)&priv->pmugrf->os_reg2);
+	priv->info.size = sdram_size_mb(priv) << 20;
 #endif
 	return 0;
 }
diff --git a/board/rockchip/evb_rk3328/evb-rk3328.c b/board/rockchip/evb_rk3328/evb-rk3328.c
index 104e0550fe..4b8a44e05e 100644
--- a/board/rockchip/evb_rk3328/evb-rk3328.c
+++ b/board/rockchip/evb_rk3328/evb-rk3328.c
@@ -34,6 +34,12 @@ int board_init(void)
 	return ret;
 }
 
+int dram_init(void)
+{
+	gd->ram_size = 0x80000000;
+	return 0;
+}
+
 int dram_init_banksize(void)
 {
 	/* Reserve 0x200000 for ATF bl31 */
diff --git a/board/rockchip/evb_rk3399/evb-rk3399.c b/board/rockchip/evb_rk3399/evb-rk3399.c
index 632ca2a2e4..2c5cc957db 100644
--- a/board/rockchip/evb_rk3399/evb-rk3399.c
+++ b/board/rockchip/evb_rk3399/evb-rk3399.c
@@ -70,6 +70,28 @@ out:
 	return 0;
 }
 
+int dram_init(void)
+{
+	struct ram_info ram;
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
+	if (ret) {
+		debug("DRAM init failed: %d\n", ret);
+		return ret;
+	}
+	ret = ram_get_info(dev, &ram);
+	if (ret) {
+		debug("Cannot get DRAM size: %d\n", ret);
+		return ret;
+	}
+	debug("SDRAM base=%llx, size=%x\n", ram.base, (unsigned int)ram.size);
+	gd->ram_size = ram.size;
+
+	return 0;
+}
+
 int dram_init_banksize(void)
 {
 	/* Reserve 0x200000 for ATF bl31 */
diff --git a/board/theobroma-systems/puma_rk3399/puma-rk3399.c b/board/theobroma-systems/puma_rk3399/puma-rk3399.c
index 1435323c62..4980b62a60 100644
--- a/board/theobroma-systems/puma_rk3399/puma-rk3399.c
+++ b/board/theobroma-systems/puma_rk3399/puma-rk3399.c
@@ -63,119 +63,28 @@ out:
 	return 0;
 }
 
-static void setup_macaddr(void)
+int dram_init(void)
 {
-#if CONFIG_IS_ENABLED(CMD_NET)
-	int ret;
-	const char *cpuid = getenv("cpuid#");
-	u8 hash[SHA256_SUM_LEN];
-	int size = sizeof(hash);
-	u8 mac_addr[6];
-
-	/* Only generate a MAC address, if none is set in the environment */
-	if (getenv("ethaddr"))
-		return;
-
-	if (!cpuid) {
-		debug("%s: could not retrieve 'cpuid#'\n", __func__);
-		return;
-	}
-
-	ret = hash_block("sha256", (void *)cpuid, strlen(cpuid), hash, &size);
-	if (ret) {
-		debug("%s: failed to calculate SHA256\n", __func__);
-		return;
-	}
-
-	/* Copy 6 bytes of the hash to base the MAC address on */
-	memcpy(mac_addr, hash, 6);
-
-	/* Make this a valid MAC address and set it */
-	mac_addr[0] &= 0xfe;  /* clear multicast bit */
-	mac_addr[0] |= 0x02;  /* set local assignment bit (IEEE802) */
-	eth_setenv_enetaddr("ethaddr", mac_addr);
-#endif
-
-	return;
-}
-
-static void setup_serial(void)
-{
-#if CONFIG_IS_ENABLED(ROCKCHIP_EFUSE)
+	struct ram_info ram;
 	struct udevice *dev;
-	int ret, i;
-	u8 cpuid[RK3399_CPUID_LEN];
-	u8 low[RK3399_CPUID_LEN/2], high[RK3399_CPUID_LEN/2];
-	char cpuid_str[RK3399_CPUID_LEN * 2 + 1];
-	u64 serialno;
-	char serialno_str[16];
+	int ret;
 
-	/* retrieve the device */
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_GET_DRIVER(rockchip_efuse), &dev);
+	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
 	if (ret) {
-		debug("%s: could not find efuse device\n", __func__);
-		return;
+		debug("DRAM init failed: %d\n", ret);
+		return ret;
 	}
-
-	/* read the cpu_id range from the efuses */
-	ret = misc_read(dev, RK3399_CPUID_OFF, &cpuid, sizeof(cpuid));
+	ret = ram_get_info(dev, &ram);
 	if (ret) {
-		debug("%s: reading cpuid from the efuses failed\n",
-		      __func__);
-		return;
+		debug("Cannot get DRAM size: %d\n", ret);
+		return ret;
 	}
-
-	memset(cpuid_str, 0, sizeof(cpuid_str));
-	for (i = 0; i < 16; i++)
-		sprintf(&cpuid_str[i * 2], "%02x", cpuid[i]);
-
-	debug("cpuid: %s\n", cpuid_str);
-
-	/*
-	 * Mix the cpuid bytes using the same rules as in
-	 *   ${linux}/drivers/soc/rockchip/rockchip-cpuinfo.c
-	 */
-	for (i = 0; i < 8; i++) {
-		low[i] = cpuid[1 + (i << 1)];
-		high[i] = cpuid[i << 1];
-	}
-
-	serialno = crc32_no_comp(0, low, 8);
-	serialno |= (u64)crc32_no_comp(serialno, high, 8) << 32;
-	snprintf(serialno_str, sizeof(serialno_str), "%llx", serialno);
-
-	setenv("cpuid#", cpuid_str);
-	setenv("serial#", serialno_str);
-#endif
-
-	return;
-}
-
-int misc_init_r(void)
-{
-	setup_serial();
-	setup_macaddr();
+	debug("SDRAM base=%llx, size=%x\n", ram.base, (unsigned int)ram.size);
+	gd->ram_size = ram.size;
 
 	return 0;
 }
 
-#ifdef CONFIG_SERIAL_TAG
-void get_board_serial(struct tag_serialnr *serialnr)
-{
-	char *serial_string;
-	u64 serial = 0;
-
-	serial_string = getenv("serial#");
-
-	if (serial_string)
-		serial = simple_strtoull(serial_string, NULL, 16);
-
-	serialnr->high = (u32)(serial >> 32);
-	serialnr->low = (u32)(serial & 0xffffffff);
-}
-#endif
-
 int dram_init_banksize(void)
 {
 	/* Reserve 0x200000 for ATF bl31 */

From c79ceb807f414fb5662207aadb9b0e4d4ed6ad70 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 18 Jun 2017 00:10:48 +0200
Subject: [PATCH 2/2] Revert "rockchip: add sdram_common for common functions"

This reverts commit 126061cac6d75c0c44602687309e2d7d59cf3f06.
---
 arch/arm/include/asm/arch-rockchip/sdram_common.h | 58 ------------------
 arch/arm/mach-rockchip/Makefile                   |  3 -
 arch/arm/mach-rockchip/sdram_common.c             | 72 -----------------------
 3 files changed, 133 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-rockchip/sdram_common.h
 delete mode 100644 arch/arm/mach-rockchip/sdram_common.c

diff --git a/arch/arm/include/asm/arch-rockchip/sdram_common.h b/arch/arm/include/asm/arch-rockchip/sdram_common.h
deleted file mode 100644
index fec85865ff..0000000000
--- a/arch/arm/include/asm/arch-rockchip/sdram_common.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
- *
- * SPDX-License-Identifier:     GPL-2.0+
- */
-
-#ifndef _ASM_ARCH_SDRAM_COMMON_H
-#define _ASM_ARCH_SDRAM_COMMON_H
-/*
- * sys_reg bitfield struct
- * [31]		row_3_4_ch1
- * [30]		row_3_4_ch0
- * [29:28]	chinfo
- * [27]		rank_ch1
- * [26:25]	col_ch1
- * [24]		bk_ch1
- * [23:22]	cs0_row_ch1
- * [21:20]	cs1_row_ch1
- * [19:18]	bw_ch1
- * [17:16]	dbw_ch1;
- * [15:13]	ddrtype
- * [12]		channelnum
- * [11]		rank_ch0
- * [10:9]	col_ch0
- * [8]		bk_ch0
- * [7:6]	cs0_row_ch0
- * [5:4]	cs1_row_ch0
- * [3:2]	bw_ch0
- * [1:0]	dbw_ch0
-*/
-#define SYS_REG_DDRTYPE_SHIFT		13
-#define SYS_REG_DDRTYPE_MASK		7
-#define SYS_REG_NUM_CH_SHIFT		12
-#define SYS_REG_NUM_CH_MASK		1
-#define SYS_REG_ROW_3_4_SHIFT(ch)	(30 + (ch))
-#define SYS_REG_ROW_3_4_MASK		1
-#define SYS_REG_CHINFO_SHIFT(ch)	(28 + (ch))
-#define SYS_REG_RANK_SHIFT(ch)		(11 + (ch) * 16)
-#define SYS_REG_RANK_MASK		1
-#define SYS_REG_COL_SHIFT(ch)		(9 + (ch) * 16)
-#define SYS_REG_COL_MASK		3
-#define SYS_REG_BK_SHIFT(ch)		(8 + (ch) * 16)
-#define SYS_REG_BK_MASK			1
-#define SYS_REG_CS0_ROW_SHIFT(ch)	(6 + (ch) * 16)
-#define SYS_REG_CS0_ROW_MASK		3
-#define SYS_REG_CS1_ROW_SHIFT(ch)	(4 + (ch) * 16)
-#define SYS_REG_CS1_ROW_MASK		3
-#define SYS_REG_BW_SHIFT(ch)		(2 + (ch) * 16)
-#define SYS_REG_BW_MASK			3
-#define SYS_REG_DBW_SHIFT(ch)		((ch) * 16)
-#define SYS_REG_DBW_MASK		3
-
-/* Get sdram size decode from reg */
-size_t rockchip_sdram_size(phys_addr_t reg);
-
-/* Called by U-Boot board_init_r for Rockchip SoCs */
-int dram_init(void);
-#endif
diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index 166a76750f..6784c0ad78 100644
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -21,9 +21,6 @@ obj-$(CONFIG_ROCKCHIP_RK3188) += rk3188-board.o
 obj-$(CONFIG_ROCKCHIP_RK322X) += rk322x-board.o
 obj-$(CONFIG_ROCKCHIP_RK3288) += rk3288-board.o
 obj-$(CONFIG_ROCKCHIP_RK3036) += rk3036-board.o
-ifdef CONFIG_RAM
-obj-y += sdram_common.o
-endif
 endif
 ifndef CONFIG_ARM64
 obj-y += rk_timer.o
diff --git a/arch/arm/mach-rockchip/sdram_common.c b/arch/arm/mach-rockchip/sdram_common.c
deleted file mode 100644
index a2189e326a..0000000000
--- a/arch/arm/mach-rockchip/sdram_common.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
- *
- * SPDX-License-Identifier:     GPL-2.0+
- */
-
-#include <common.h>
-#include <dm.h>
-#include <ram.h>
-#include <asm/io.h>
-#include <asm/arch/sdram_common.h>
-#include <dm/uclass-internal.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-size_t rockchip_sdram_size(phys_addr_t reg)
-{
-	u32 rank, col, bk, cs0_row, cs1_row, bw, row_3_4;
-	size_t chipsize_mb = 0;
-	size_t size_mb = 0;
-	u32 ch;
-
-	u32 sys_reg = readl(reg);
-	u32 ch_num = 1 + ((sys_reg >> SYS_REG_NUM_CH_SHIFT)
-		       & SYS_REG_NUM_CH_MASK);
-
-	for (ch = 0; ch < ch_num; ch++) {
-		rank = 1 + (sys_reg >> SYS_REG_RANK_SHIFT(ch) &
-			SYS_REG_RANK_MASK);
-		col = 9 + (sys_reg >> SYS_REG_COL_SHIFT(ch) & SYS_REG_COL_MASK);
-		bk = 3 - ((sys_reg >> SYS_REG_BK_SHIFT(ch)) & SYS_REG_BK_MASK);
-		cs0_row = 13 + (sys_reg >> SYS_REG_CS0_ROW_SHIFT(ch) &
-				SYS_REG_CS0_ROW_MASK);
-		cs1_row = 13 + (sys_reg >> SYS_REG_CS1_ROW_SHIFT(ch) &
-				SYS_REG_CS1_ROW_MASK);
-		bw = (2 >> ((sys_reg >> SYS_REG_BW_SHIFT(ch)) &
-			SYS_REG_BW_MASK));
-		row_3_4 = sys_reg >> SYS_REG_ROW_3_4_SHIFT(ch) &
-			SYS_REG_ROW_3_4_MASK;
-
-		chipsize_mb = (1 << (cs0_row + col + bk + bw - 20));
-
-		if (rank > 1)
-			chipsize_mb += chipsize_mb >> (cs0_row - cs1_row);
-		if (row_3_4)
-			chipsize_mb = chipsize_mb * 3 / 4;
-		size_mb += chipsize_mb;
-	}
-
-	return size_mb << 20;
-}
-
-int dram_init(void)
-{
-	struct ram_info ram;
-	struct udevice *dev;
-	int ret;
-
-	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
-	if (ret) {
-		debug("DRAM init failed: %d\n", ret);
-		return ret;
-	}
-	ret = ram_get_info(dev, &ram);
-	if (ret) {
-		debug("Cannot get DRAM size: %d\n", ret);
-		return ret;
-	}
-	debug("SDRAM base=%x, size=%x\n", (u32)ram.base, (u32)ram.size);
-	gd->ram_size = ram.size;
-
-	return 0;
-}
