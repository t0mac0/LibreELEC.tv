From b9760a816fd5019c48ca5322169dbb9e6046ade5 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 17 Jun 2017 08:29:29 +0200
Subject: [PATCH 27/27] gpu/drm/rockchip: hdmi fix from rockchip

---
 drivers/gpu/drm/bridge/dw-hdmi.c            | 43 ++++++++++++++++++-----------
 drivers/gpu/drm/drm_edid.c                  | 24 ++++++++++++++++
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c | 31 ++++++++++++---------
 3 files changed, 69 insertions(+), 29 deletions(-)

diff --git a/drivers/gpu/drm/bridge/dw-hdmi.c b/drivers/gpu/drm/bridge/dw-hdmi.c
index f0a1d41e4716..a5598d66d2b3 100644
--- a/drivers/gpu/drm/bridge/dw-hdmi.c
+++ b/drivers/gpu/drm/bridge/dw-hdmi.c
@@ -209,7 +209,8 @@ struct dw_hdmi {
 
 	int vic;
 
-	u8 edid[HDMI_EDID_LEN];
+//	u8 edid[HDMI_EDID_LEN];
+	struct edid *edid;
 	bool cable_plugin;
 
 	struct {
@@ -414,7 +415,7 @@ static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
 		    HDMI_IH_MUTE_I2CM_STAT0);
 
 	/* set SDA high level holding time */
-	hdmi_writeb(hdmi, 0x48, HDMI_I2CM_SDA_HOLD);
+//	hdmi_writeb(hdmi, 0x48, HDMI_I2CM_SDA_HOLD);
 
 	dw_hdmi_i2c_set_divs(hdmi);
 }
@@ -425,6 +426,7 @@ static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
 	struct dw_hdmi_i2c *i2c = hdmi->i2c;
 	int stat;
 
+	pr_info("%s length %d\n", __func__, length);
 	if (!i2c->is_regaddr) {
 		dev_dbg(hdmi->dev, "set read register address to 0\n");
 		i2c->slave_reg = 0x00;
@@ -433,7 +435,6 @@ static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
 
 	while (length--) {
 		reinit_completion(&i2c->cmp);
-
 		hdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
 		if (i2c->is_segment)
 			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ_EXT,
@@ -443,13 +444,15 @@ static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
 				    HDMI_I2CM_OPERATION);
 
 		stat = wait_for_completion_timeout(&i2c->cmp, HZ / 10);
-		if (!stat)
+		if (!stat) {
+			pr_info("%s slave_reg %d time out\n", __func__, i2c->slave_reg);
 			return -EAGAIN;
-
+		}
 		/* Check for error condition on the bus */
-		if (i2c->stat & HDMI_IH_I2CM_STAT0_ERROR)
+		if (i2c->stat & HDMI_IH_I2CM_STAT0_ERROR) {
+			pr_info("%s slave_reg %d -EIO\n", __func__, i2c->slave_reg);
 			return -EIO;
-
+		}
 		*buf++ = hdmi_readb(hdmi, HDMI_I2CM_DATAI);
 	}
 	i2c->is_segment = false;
@@ -1663,9 +1666,9 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
 		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
 
-	inv_val |= hdmi->sink_is_hdmi ?
-		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
-		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
+//	inv_val |= hdmi->sink_is_hdmi ?
+//		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
+//		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
 
 	hdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);
 
@@ -1925,7 +1928,9 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi, struct drm_display_mode *mode)
 	/* not for DVI mode */
 	if (hdmi->sink_is_hdmi) {
 		dev_dbg(hdmi->dev, "%s HDMI mode\n", __func__);
-
+		hdmi_modb(hdmi, HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE,
+			  HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE,
+			  HDMI_FC_INVIDCONF);
 		/* HDMI Initialization Step F - Configure AVI InfoFrame */
 		hdmi_config_AVI(hdmi, mode);
 		hdmi_config_vendor_specific_infoframe(hdmi, mode);
@@ -2080,6 +2085,9 @@ static void dw_hdmi_bridge_disable(struct drm_bridge *bridge)
 
 	mutex_lock(&hdmi->mutex);
 	hdmi->disabled = true;
+	pr_info("%s\n", __func__);
+	kfree(hdmi->edid);
+	hdmi->edid = NULL;
 	dw_hdmi_update_power(hdmi);
 	dw_hdmi_update_phy_mask(hdmi);
 	mutex_unlock(&hdmi->mutex);
@@ -2125,8 +2133,10 @@ static int dw_hdmi_connector_get_modes(struct drm_connector *connector)
 
 	if (!hdmi->ddc)
 		return 0;
-
-	edid = drm_get_edid(connector, hdmi->ddc);
+	if (hdmi->edid)
+		edid = hdmi->edid;
+	else
+		edid = drm_get_edid(connector, hdmi->ddc);
 	if (edid) {
 		dev_dbg(hdmi->dev, "got edid: width[%d] x height[%d]\n",
 			edid->width_cm, edid->height_cm);
@@ -2137,9 +2147,10 @@ static int dw_hdmi_connector_get_modes(struct drm_connector *connector)
 		ret = drm_add_edid_modes(connector, edid);
 		/* Store the ELD */
 		drm_edid_to_eld(connector, edid);
-		kfree(edid);
+		hdmi->edid = edid;
+		//kfree(edid);
 	} else {
-		dev_dbg(hdmi->dev, "failed to get edid\n");
+		dev_err(hdmi->dev, "failed to get edid\n");
 	}
 
 	return ret;
@@ -2512,7 +2523,7 @@ dw_hdmi_ctrl_write(struct file *file, const char __user *buf,
 		return -EFAULT;
 	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
 		return -EFAULT;
-	if ((reg < 0) || (reg > HDMI_I2CM_FS_SCL_LCNT_0_ADDR)) {
+	if ((reg < 0) || (reg > 0x7e13)) {
 		dev_err(hdmi->dev, "it is no a hdmi register\n");
 		return count;
 	}
diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c
index a0cc3bf0ef57..6d2aabb4a3ee 100644
--- a/drivers/gpu/drm/drm_edid.c
+++ b/drivers/gpu/drm/drm_edid.c
@@ -4321,6 +4321,29 @@ int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)
 }
 EXPORT_SYMBOL(drm_add_edid_modes);
 
+static int drm_add_hdmimodes_noedid(struct drm_connector *connector)
+{
+	int i, num_modes = 0;
+	struct drm_display_mode *mode;
+	struct drm_device *dev = connector->dev;
+
+	for (i = 0; i < ARRAY_SIZE(edid_cea_modes); i++) {
+		const struct drm_display_mode *ptr = &edid_cea_modes[i];
+		if (ptr->hdisplay > 1920 ||
+		    ptr->vdisplay < 480 ||
+		    ptr->flags & DRM_MODE_FLAG_INTERLACE ||
+		    drm_mode_vrefresh(ptr) > 60 ||
+		    drm_mode_vrefresh(ptr) < 50)
+			continue;
+		mode = drm_mode_duplicate(dev, ptr);
+		if (mode) {
+			drm_mode_probed_add(connector, mode);
+			num_modes++;
+		}
+	}
+	return num_modes;
+}
+
 /**
  * drm_add_modes_noedid - add modes for the connectors without EDID
  * @connector: connector we're probing
@@ -4339,6 +4362,7 @@ int drm_add_modes_noedid(struct drm_connector *connector,
 	struct drm_display_mode *mode;
 	struct drm_device *dev = connector->dev;
 
+	return drm_add_hdmimodes_noedid(connector);
 	count = ARRAY_SIZE(drm_dmt_modes);
 	if (hdisplay < 0)
 		hdisplay = 0;
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 8c67659da743..8d48d70c50ed 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -254,7 +254,7 @@ inno_dw_hdmi_phy_init(struct dw_hdmi *dw_hdmi, void *data,
 		return -EINVAL;
 
 	/* set pdata_en to 0 */
-	inno_phy_modeb(hdmi, 0, 1, 0x01);
+	inno_phy_modeb(hdmi, 0, 1, 0x02);
 	/* Power off post PLL */
 	inno_phy_modeb(hdmi, 1, 1, 0xaa);
 
@@ -273,14 +273,6 @@ inno_dw_hdmi_phy_init(struct dw_hdmi *dw_hdmi, void *data,
 		inno_phy_writel(hdmi, 0xab, val);
 		inno_phy_writel(hdmi, 0xaa, 0x0e);
 	}
-	/* Power up post PLL */
-	inno_phy_modeb(hdmi, 0, 1, 0xaa);
-	/* Wait for post PLL lock */
-	for (i = 0; i < 5; ++i) {
-		if (inno_phy_readl(hdmi, 0xaf) & 1)
-			break;
-		usleep_range(1000, 2000);
-	}
 
 	for (i = 0; i < 14; i++)
 		inno_phy_writel(hdmi, 0xb5 + i, inno_phy_config->regs[i]);
@@ -317,13 +309,26 @@ inno_dw_hdmi_phy_init(struct dw_hdmi *dw_hdmi, void *data,
 		inno_phy_writel(hdmi, 0xc5, 0x81);
 	}
 
-	if (inno_phy_config->tmdsclock > 340000000)
-		msleep(100);
-
+	/* Power up post PLL */
+	inno_phy_modeb(hdmi, 0, 1, 0xaa);
+	/* Power up tmds driver */
 	inno_phy_modeb(hdmi, 4, 4, 0xb0);
 	inno_phy_writel(hdmi, 0xb2, 0x0f);
+
+	/* Wait for post PLL lock */
+	for (i = 0; i < 5; ++i) {
+		if (inno_phy_readl(hdmi, 0xaf) & 1)
+			break;
+		usleep_range(1000, 2000);
+	}
+	if (!(inno_phy_readl(hdmi, 0xaf) & 1)) {
+		dev_err(hdmi->dev, "HDMI PHY Post PLL unlock\n");
+		return -ETIMEDOUT;
+	}
+	if (inno_phy_config->tmdsclock > 340000000)
+		msleep(100);
 	/* set pdata_en to 1 */
-	inno_phy_modeb(hdmi, 1, 1, 0x01);
+	inno_phy_modeb(hdmi, 1, 1, 0x02);
 	return 0;
 }
 
